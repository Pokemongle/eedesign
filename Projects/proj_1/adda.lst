C51 COMPILER V9.01   ADDA                                                                  05/18/2023 15:56:12 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE ADDA
OBJECT MODULE PLACED IN .\adda.obj
COMPILER INVOKED BY: D:\C51\BIN\C51.EXE ..\..\App\adda.c BROWSE INCDIR(..\..\Public;..\..\App) DEBUG OBJECTEXTEND PRINT(
                    -.\adda.lst) OBJECT(.\adda.obj)

line level    source

   1          //==头文件==
   2          #include <absacc.h>
   3          #include <intrins.h>
   4          #include <math.h>
   5          #include <STC12C5A.h> // 51标准头文件
   6          #include "adda.h"
   7          #include "key.h"
   8          #include "led.h"
   9          
  10          //==========
  11          //==全局变量==
  12          unsigned char
  13                  ad_max = 128,  // 测量信号当前最大值
  14                  ad_min = 128,  // 测量信号当前最小值
  15                  ad_result = 128, // A/D单次采集信号结果
  16                  amp_p1 = 129,    // 频率测量指针1
  17                  amp_p2 = 129,    // 频率测量指针2
  18                  da_count = 0,    // 信号发生器定时计数
  19                  da_result = 0,   // 信号发生器单次产生的数字信号
  20                  fre_count = 0,   // 幅值测量计数
  21                  fre_p1 = 1,              // 频率测量指针1 
  22                  fre_p2 = 1,              // 频率测量指针2
  23                  fre_sum = 0,     // 频率测量累加
  24                  rec_count = 0,   // 方波信号发生计数
  25                  rec_value = 64,  // 方波信号
  26                  review_p = 0,  // D/A回放显示指针
  27                  saw_value = 64,  // 锯齿波信号
  28                  time_count = 0,  // 测量时间计数
  29                  tri_value = 64,  // 三角波信号
  30                  tri_flag = 1;    // 三角波幅值递增递减标志
  31          
  32          unsigned int 
  33                  angle = 0,         // 正弦波角度，角度值，[0,360]
  34                  memo_p = 0;        // A/D采集存储区指针
  35          
  36          float
  37                  sinAngle = 0.0f,  // 正弦波角度，弧度制，[-1,1]
  38                  fre_es = 0.0f,    // 测量的频率
  39                  amp_es = 0.0f;    // 幅值测量值，弧度制，[-5,5]
  40          unsigned char xdata
  41              ad_memo[MEMO_LEN];  // A/D采集信号存储区
  42          //============
  43          //==函数==
  44          unsigned char ad_get()// A/D采样（单次）
  45          {
  46   1          ADC_CONTR = ADC_CONTR | ADC_POWER | 3 | ADC_START;
  47   1          _nop_(); // wait
  48   1          _nop_();
  49   1          _nop_();
  50   1          _nop_();
  51   1          while (!(ADC_CONTR & ADC_FLAG))
  52   1              ;                   // 等待A/D标志位变1，ADC_FLAG
  53   1          ADC_CONTR &= ~ADC_FLAG; // 标志位清零
  54   1          return ADC_RES;
C51 COMPILER V9.01   ADDA                                                                  05/18/2023 15:56:12 PAGE 2   

  55   1      }
  56          void ad_save() // A/D采样值存储
  57          {
  58   1          ad_memo[memo_p++] = ad_result;
  59   1          if (memo_p >= MEMO_LEN)
  60   1          {
  61   2              memo_p = 0;
  62   2          }
  63   1      }
  64          void ad_measure()       // 频率幅值单次检测
  65          {
  66   1              // 频率测量
  67   1              amp_p2 = ad_result;
  68   1              time_count++;
  69   1              if(amp_p2 > 128 && amp_p1 <= 128){
  70   2                      fre_p2 = time_count; 
  71   2                      if(fre_p1 != 0){
  72   3                              fre_sum = fre_sum + fabs(fre_p2 - fre_p1);
  73   3                              fre_count++;
  74   3                      }
  75   2                      fre_p1 = fre_p2;        
  76   2              }
  77   1              amp_p1 = amp_p2;
  78   1      
  79   1              // 幅值测量
  80   1              if(ad_result > ad_max){
  81   2                      ad_max = ad_result;
  82   2              }       
  83   1              if(ad_result < ad_min){
  84   2                      ad_min = ad_result;
  85   2              }
  86   1              if(time_count >= AD_LEN){
  87   2                      fre_es = 1500.0f / (fre_sum * 1.0f / fre_count);
  88   2                      amp_es = 5.0f * ((ad_max-ad_min)/256.0f);
  89   2                      fre_sum = 0;fre_count = 0;
  90   2                      time_count = 0;
  91   2                      fre_p1 = fre_p2 = 0;
  92   2                      amp_p1 = amp_p2 = 129;
  93   2                      ad_max = ad_min = 128;
  94   2              }       
  95   1      }
  96          void da_display()
  97          {                                                                               
  98   1              switch(mode){
  99   2                      case 1:{         // 模式1 CH1实时显示
 100   3                              DA_CH1 = ad_result;// 实时显示
 101   3                      };break;
 102   2                      case 2:{         // 模式2 CH1实时显示 CH2回放显示
 103   3                              DA_CH1 = ad_result;// 实时显示
 104   3                              DA_CH2 = ad_memo[review_p++]; // 回放显示
 105   3                              if (review_p >= MEMO_LEN){ // 若显示指针到达存储区末尾，从头开始显示
 106   4                              review_p = 0;
 107   4                              }
 108   3                      };break;
 109   2                      default: ;break;
 110   2              }
 111   1      }
 112          void da_generator()// 信号发生器
 113          {
 114   1              switch(wave_sel){ // 根据wave_sel的选择产生相应波形
 115   2                      case SIN:{      // 正弦波
 116   3                              angle++;
C51 COMPILER V9.01   ADDA                                                                  05/18/2023 15:56:12 PAGE 3   

 117   3                              if(angle > 360){
 118   4                                      angle = 0;
 119   4                              }
 120   3                              sinAngle =      sin(((float)angle * PI / 180.0f));// 求角度对应的弧度值[-1,1]
 121   3                              da_result = (int)(((sinAngle + 1.0f) / 2.0f) * 255.0f); // 将[-1,1]内的sin值映射到[0,255]
 122   3                      };break;
 123   2                      case TRI:{      // 三角波
 124   3                              if(tri_flag){//递增
 125   4                                      tri_value++;
 126   4                                      if(tri_value == 255){
 127   5                                              tri_flag = 0;
 128   5                                      }       
 129   4                              }
 130   3                              else{//递减
 131   4                                      tri_value--;
 132   4                                      if(tri_value == 0){
 133   5                                              tri_flag = 1;
 134   5                                      }
 135   4                              }        
 136   3                              da_result = tri_value;  
 137   3                      };break;        
 138   2                      case REC:{      // 方波
 139   3                              rec_count++;
 140   3                              if(rec_count == 200){
 141   4                                      rec_count = 0;                  
 142   4                              }
 143   3                              if(rec_count>100){
 144   4                                      da_result = 255;
 145   4                              }else{
 146   4                                      da_result = 0;
 147   4                              }               
 148   3                      };break;
 149   2                      case SAW:{      // 锯齿波
 150   3                              saw_value++;
 151   3                              if(saw_value > 255){
 152   4                                      saw_value = 0;
 153   4                              }       
 154   3                              da_result = saw_value;
 155   3                      };break;
 156   2                      default:da_result = 128;break;  
 157   2              }
 158   1      }
 159          void da_process(){      // 处理待显示的D/A输出值
 160   1              da_result = (int)(da_result * 1.0f / da_index + 128.0f -128.0f / da_index); 
 161   1      }
 162          void dspbuf_measure()   // 将采样得到的频率和幅值显示到数码管上
 163          {
 164   1              // 频率值转换为数码管显示
 165   1              if(flag_fre){
 166   2                      unsigned int integer_fre = 0;
 167   2                      unsigned int fraction_fre = 0;
 168   2                      integer_fre = (int)fre_es;
 169   2                      dspbuf[3] = dspchar[integer_fre % 10];
 170   2                      dspbuf[2] = dspchar[integer_fre / 10 % 10];
 171   2                      dspbuf[1] = dspchar[integer_fre / 100 % 10];
 172   2                      dspbuf[0] = dspchar[integer_fre / 1000 % 10];
 173   2              }
 174   1              // 幅值转换为数码管显示
 175   1              else if(flag_amp){
 176   2                      if(amp_es >= 0.0f && amp_es <10.0f){
 177   3                              unsigned int integer_amp = 0;
 178   3                              unsigned int fraction_amp = 0;
C51 COMPILER V9.01   ADDA                                                                  05/18/2023 15:56:12 PAGE 4   

 179   3                              integer_amp = (int) amp_es;
 180   3                              fraction_amp = (int) ((amp_es-integer_amp)*1000);
 181   3                              dspbuf[0] = dspchar[integer_amp] & 0xfe;// 加小数点
 182   3                              dspbuf[1] = dspchar[fraction_amp / 100 % 10];
 183   3                              dspbuf[2] = dspchar[fraction_amp / 10 % 10];
 184   3                              dspbuf[3] = dspchar[fraction_amp % 10];
 185   3                      }
 186   2              } 
 187   1      }
 188          //========


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    955    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   8000    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
