C51 COMPILER V9.01   MAIN                                                                  05/15/2023 13:34:11 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\C51\BIN\C51.EXE main.c BROWSE INCDIR(..\..\Public;..\..\App) DEBUG OBJECTEXTEND

line level    source

   1          /*
   2           * @ packaged_edition
   3           * - package edition 主程序
   4           * - 各模块封装于 Projects, App, Obj, Public 文件夹中便于维护
   5           * - ../../demos文件夹为 master git 库，用于版本控制
   6           *
   7           */
   8          
   9          //==头文件==
  10          #include <STC12C5A.h> // 51标准头文件
  11          #include <absacc.h>       // 时钟分频？
  12          #include <intrins.h>  // 用于调用系统延时函数 _nop_()
  13          #include <math.h>         // 用于调用数学函数 sin, abs等
  14          #include "adda.h"
  15          #include "key.h"
  16          #include "led.h"
  17          #define DA_CH1 XBYTE[0x4000] // DA显示通道CH1
  18          #define DA_CH2 XBYTE[0x2000] // DA显示通道CH2
  19          //==========
  20          //==函数声明==
  21          void init_ad();//A/D初始化
  22          void init_special_interrupts(); // 中断初始化
  23          void init_timer0(); // 定时器0初始化
  24          
  25          //============
  26          
  27          //==函数体==
  28          void main()
  29          {                                                                                                                                                                                                                                                                                                   
  30   1          init_timer0();
  31   1          init_special_interrupts();
  32   1          init_ad();
  33   1          while (1)
  34   1          {
  35   2              
  36   2                      if(key_sta & 0x01){//key_sta.0 = 0x01? key_sta.0 = 1检测到按键按下
  37   3                              mode_select();
  38   3                              key_sta = key_sta & 0xfe;//key_sta.0 = 0,按键弹起，等待下一次检测到按下
  39   3                      }
  40   2          }
  41   1      }
  42          void interrupt_timer0() interrupt 1 // 定时器0中断处理
  43          {
  44   1              EA = 0;
  45   1              ad_result = ad_get();// 单次采样                
  46   1      
  47   1              if(mode == 1){          // CH1：实时采样并存储 CH2: 信号发生器
  48   2                      // 信号发生
  49   2                      da_count++;
  50   2                      if(da_count >= gen_count){ // gen_count = 4时，每隔1ms输出一次D/A
  51   3                              da_count = 0;
  52   3                              da_generator();
  53   3                              da_process();   // 显示值预处理
  54   3                      }
  55   2                      // 模式1对实时采样值进行存储
C51 COMPILER V9.01   MAIN                                                                  05/15/2023 13:34:11 PAGE 2   

  56   2                      ad_result = ((int)(ad_result / 2.0 + 64));
  57   2                      ad_save();
  58   2              }
  59   1              else if(mode == 2){     // CH1: 实时采样 CH2: 波形回放显示
  60   2                      ad_result = ((int)(ad_result / 2.0 + 64));      
  61   2              }
  62   1              else if(mode == 3){ // CH1: 实时采样 CH2: 输出0V        
  63   2                      //time_count++;
  64   2                      ad_measure();
  65   2                      dspbuf_measure();//数码管显示缓存改变
  66   2                      ad_result = ((int)(ad_result / 2.0 + 64));
  67   2              }
  68   1              else if(mode == 4){     // CH1: 实时采样 CH2: 信号发生器，调频调幅
  69   2                      // 信号发生器
  70   2                      da_count++;
  71   2                      if(da_count >= gen_count){ // gen_count = 4时，每隔1ms输出一次D/A
  72   3                              da_count = 0;
  73   3                              da_generator();
  74   3                              da_process();   // 显示值预处理
  75   3                      }       
  76   2              }
  77   1              dsptask();              // 数码管扫描
  78   1              key_service();  // 按键扫描
  79   1          da_display();       // D/A显示
  80   1              EA = 1;
  81   1      }
  82          void init_ad() // ad寄存器初始化
  83          {
  84   1          P1ASF = 0x08;     // P1.3作为ad输入
  85   1          ADC_CONTR = 0xE3; // ADC控制寄存器         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bit1    Bit
             -0
  86   1                            // 位描述            ADC_POWER  SPEED1 SPEED0 ADC_FLAG ADC_START CHS2    CHS1    CHS
             -0
  87   1                            // 初始值=0000,0000      0       0       0       0       0       0       0       0
  88   1                            // 设置值=0000,0000      1       1       1       0       0       0       1       1
  89   1          AUXR1 &= 0xfb;    // 高8位存储在在ADC_RES
  90   1          CLK_DIV = 0x01;   // 系统时钟/2
  91   1      }
  92          void init_timer0() // 定时器0初始化
  93          {                  // 1/4ms
  94   1          TMOD &= 0XF0;  // Timer0设置清除
  95   1          TMOD |= 0X02;  // 8位自动重载模式
  96   1          TL0 = 0X06;
  97   1          TH0 = 0X06;
  98   1          TR0 = 1;
  99   1          ET0 = 1;
 100   1      }
 101          void init_special_interrupts() // 中断初始化
 102          {
 103   1          EX0 = 0;
 104   1          ET0 = 1; // 定时器0中断
 105   1          EX1 = 0;
 106   1          ET1 = 1; // 定时器1中断
 107   1          ES = 1;      // 外部中断
 108   1          EA = 1;  // 总中断
 109   1          PT0 = 0;
 110   1          PX1 = 1;
 111   1          PS = 0;
 112   1      }
 113          //==========


C51 COMPILER V9.01   MAIN                                                                  05/15/2023 13:34:11 PAGE 3   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    283    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
