C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TEST1
OBJECT MODULE PLACED IN test1.OBJ
COMPILER INVOKED BY: D:\C51\BIN\C51.EXE test1.c BROWSE INCDIR(..\..\Public) DEBUG OBJECTEXTEND

line level    source

   1          //==========头文件=========
   2          #include <STC12C5A.h>
   3          #include <absacc.h>
   4          #include <intrins.h>
   5          #include <math.h>
   6          //=========================
   7          
   8          //===============宏定义======================
   9          #define DA_CH1 XBYTE[0x4000] // DA显示通道CH1
  10          #define DA_CH2 XBYTE[0x2000] // DA显示通道CH2
  11          #define MEMO_LEN        8000 // 回放显示存储长度(BYTE)
  12          #define WIN_SIZE        8
  13          #define AD_LEN 250
  14          #define SIN 1// 正弦波
  15          #define TRI 2// 三角波
  16          #define REC     3// 方波
  17          #define SAW 4// 锯齿波
  18          #define PI 3.1415926535          // 数学常数Π
  19          //===========================================
  20          
  21          //============管脚定义================
  22          //---------数码管连接芯片74CH565
  23          sbit D_SER = P1 ^ 0;
  24          sbit D_SRCLK = P1 ^ 1;
  25          sbit D_RCLK = P1 ^ 2;
  26          //---------键盘行扫描
  27          sbit KEY1 = P3 ^ 5;
  28          sbit KEY2 = P3 ^ 4;
  29          //===================================
  30          
  31          //============函数声明===============
  32          void ad_save();                 // A/D采样值存储
  33          void ad_measure();                              // A/D测量
  34          void amp_measure();                             // 幅值检测
  35          void da_display();              // D/A显示
  36          void da_generator();                    // 信号发生器
  37          void da_process();                              // 处理[0,255]内的待显示D/A输出值
  38          void dsptask();                 // 数码管显示函数
  39          void dspbuf_measure();                  // 模式3，数码管显示缓存区为当前测量值
  40          void fdisp(unsigned char n,unsigned char m);// 单个数码管显示                           
  41          //n为数码管显示的数字 m为数码管位选     
  42          unsigned char ad_get();         // A/D采样（单次）
  43          void init_ad();                 // 内部A/D寄存器初始化
  44          void init_timer0();             // 定时器0初始化
  45          void init_special_interrupts(); // 中断初始化
  46          //void key_scan();                              // 按键扫描
  47          void key_service();                             // 按键扫描
  48          void mode_select();                         // 模式选择，修改对应数码管缓存区
  49          //void memo_increment();                        // 存储读取位置更改 
  50          //--模式1：波形实时显示模式
  51          //---------CH1: 采样实时输出，同时存储输入
  52          //---------CH2: 信号发生器      正弦波|三角波|方波|锯齿波                                               
  53          //--模式2：波形回放显示模式                                                                                                                     
  54          //---------CH1: 采样实时输出
  55          //---------CH2：输出模式1中存储的信号的波形                                                                                                                             
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 2   

  56          //--模式3：测量模式
  57          //--模式4：调幅、调频模式
  58          //---------CH1: 采样实时输出
  59          //---------CH2: 信号发生器      正弦波|三角波|方波|锯齿波
  60          
  61          //===============全局变量声明===========================
  62          unsigned char 
  63          dspbuf[4] = {    // 数码管显示缓存
  64              0x11, 0x11, 0x11, 0x11
  65          }, 
  66          dspchar[10] = {  // 数码管字符表0-9
  67                  0x11,0x7d,0x23,0x29,
  68                  0x4d,0x89,0x81,0x3d,
  69                  0x01,0x09       
  70          },
  71          /*
  72                          case 0: c = 0x11; break;
  73                          case 1: c = 0x7d; break;
  74                          case 2: c = 0x23; break;
  75                          case 3: c = 0x29; break;
  76                          case 4: c = 0x4d; break;
  77                          case 5: c = 0x89; break;
  78                          case 6: c = 0x81; break;
  79                          case 7: c = 0x3d; break;
  80                          case 8: c = 0x01; break;
  81                          case 9: c = 0x09; break;
  82                          default:c = 0xff; break;
  83          
  84          keysta[8] = {    // 按键状态，0-弹起，1-按下
  85                  0,0,0,0,
  86                  0,0,0,0
  87          },
  88          backup[8] = {    // 按键值备份，保存前一次的值
  89                  0,0,0,0,
  90                  0,0,0,0
  91          },
  92          keybuf[8] = {    // 按键扫描缓冲区
  93                  0x00,0x00,0x00,0x00,
  94                  0x00,0x00,0x00,0x00     
  95          },*/
  96              sel = 0,            // 数码管位选
  97              key_sta = 0;        // 按键状态
  98          unsigned char xdata
  99              ad_memo[MEMO_LEN];  // A/D采集信号存储区
 100          unsigned char
 101                  amp_modi = 0,  // 调幅标志
 102                  fre_modi = 0,  // 调频标志
 103                  ad_max = 128,  // 测量信号当前最大值
 104                  ad_min = 128,  // 测量信号当前最小值
 105                  ad_count = 0,  // A/D采样计数
 106              ad_result = 128, // A/D单次采集信号结果
 107                  dag_p = 0,         // 信号发生器指针
 108                  da_result = 0, // 信号发生器单次产生的数字信号
 109                  flag_amp = 0,  // 数码管显示幅值
 110                  flag_fre = 0,  // 数码管显示频率标志
 111                  key_col = 0,   // 按键扫描当前列
 112                  key_num = 0,   // 按键序号
 113                  memo_p = 0,        // A/D采集存储区指针
 114                  mode = 0,          // 模式选择
 115                  review_p = 0,  // D/A回放显示指针
 116                  rec_count = 0, // 方波信号发生计数
 117                  saw_value = 64,// 锯齿波信号
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 3   

 118                  rec_value = 64,// 方波信号
 119                  tri_value = 64,// 三角波信号
 120                  tri_flag = 1,  // 三角波幅值递增递减标志
 121                  //volt_max = 192,// 电压最大值
 122                  //volt_min = 64, // 电压最小值
 123                  wave_sel = 0,  // 信号发生器波形选择
 124                  i = 0,             // 按键扫描位选
 125                  fre_p1 = 1,        // 频率测量指针1 
 126                  fre_p2 = 1,        // 频率测量指针2
 127                  amp_p1 = 129,  // 频率测量指针
 128                  amp_p2 = 129,  // 频率测量指针
 129                  key_p = 0;         // 按键扫描缓冲区指针
 130          unsigned int
 131                  //fre_es = 0,    // 测量的频率
 132                  fre_count = 0, // 幅值测量计数
 133                  fre_sum = 0,   // 频率测量累加
 134                  time_count = 0,// 测量时间计数
 135                  angle = 0,         // 正弦波角度，角度值，[0,360]
 136                  da_count = 0,  // 信号发生器定时计数
 137                  da_index = 2,// 调幅参数
 138              clocktime = 0, //
 139                  gen_count = 4; // 信号发生器频率控制
 140                  
 141          float 
 142                  sinAngle = 0.0f,  // 正弦波角度，弧度制，[-1,1] 
 143                  fre_es = 0.0f,    // 测量的频率
 144                  amp_es = 0.0f;    // 幅值测量值，弧度制，[-5,5]
 145          
 146              
 147          
 148          //======================================================
 149          
 150          //==============函数体===============
 151          void main()
 152          {                                                                                                                                                                                                                                                                                                   
 153   1          init_timer0();
 154   1          init_special_interrupts();
 155   1          init_ad();
 156   1          while (1)
 157   1          {
 158   2              
 159   2                      if(key_sta & 0x01){//key_sta.0 = 0x01? key_sta.0 = 1检测到按键按下
 160   3                              mode_select();
 161   3                              key_sta = key_sta & 0xfe;//key_sta.0 = 0,按键弹起，等待下一次检测到按下
 162   3                      }
 163   2          }
 164   1      }
 165          void interrupt_timer0() interrupt 1 // 定时器0中断处理
 166          {
 167   1              EA = 0;
 168   1              ad_result = ad_get();// 单次采样                
 169   1      
 170   1              if(mode == 1){          // CH1：实时采样并存储 CH2: 信号发生器
 171   2                      // 信号发生
 172   2                      da_count++;
 173   2                      if(da_count >= gen_count){ // gen_count = 4时，每隔1ms输出一次D/A
 174   3                              da_count = 0;
 175   3                              da_generator();
 176   3                              da_process();   // 显示值预处理
 177   3                      }
 178   2                      // 模式1对实时采样值进行存储
 179   2                      ad_result = ((int)(ad_result / 2.0 + 64));
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 4   

 180   2                      ad_save();
 181   2              }
 182   1              else if(mode == 2){     // CH1: 实时采样 CH2: 波形回放显示
 183   2                      ad_result = ((int)(ad_result / 2.0 + 64));      
 184   2              }
 185   1              else if(mode == 3){ // CH1: 实时采样 CH2: 输出0V        
 186   2                      //time_count++;
 187   2                      ad_measure();
 188   2                      /*
 189   2                      if(time_count >= 250){// 0.25ms*400=0.1s更新一次测量值
 190   2                              time_count = 0;
 191   2                              //fre_es = fre_count / 0.15f;  // 输出测量频率
 192   2                              fre_es = 500.0f / (fre_sum * 1.0f / fre_count);
 193   2                              amp_es = 5.0f*((ad_max - ad_min) / 256.0f); // 输出测量幅值
 194   2                              fre_sum = 0; fre_count = 0;
 195   2                              fre_p1 = fre_p2 = 1;
 196   2                              amp_p1 = amp_p2 = 129;
 197   2                              ad_max = ad_min = 128;
 198   2                      }
 199   2                 */
 200   2                      dspbuf_measure();//数码管显示缓存改变
 201   2                      ad_result = ((int)(ad_result / 2.0 + 64));
 202   2              }
 203   1              else if(mode == 4){     // CH1: 实时采样 CH2: 信号发生器，调频调幅
 204   2                      // 信号发生器
 205   2                      da_count++;
 206   2                      if(da_count >= gen_count){ // gen_count = 4时，每隔1ms输出一次D/A
 207   3                              da_count = 0;
 208   3                              da_generator();
 209   3                              da_process();   // 显示值预处理
 210   3                      }       
 211   2              }
 212   1              dsptask();              // 数码管扫描
 213   1              key_service();  // 按键扫描
 214   1              //da_process(); // 显示值预处理
 215   1              //ad_result = ((int)(ad_result / 2.0 + 64)); // 输出预处理
 216   1          da_display();       // D/A显示
 217   1              EA = 1;
 218   1      }
 219          void da_process(){      // 处理待显示的D/A输出值
 220   1              da_result = (int)(da_result * 1.0f / da_index + 128.0f -128.0f / da_index); 
 221   1              //da_result = (int)((da_result - 128.0f)*(da_index * 1.0f / 10000.0f) + 128.0f);
 222   1              //da_result = (int)(da_result * 1.0f / da_index + 128.0f -128.0f / da_index);
 223   1      }
 224          void da_display()
 225          {                                                                               
 226   1              switch(mode){
 227   2                      case 1:{         // 模式1 CH1实时显示 CH2信号发生器
 228   3                              DA_CH1 = ad_result;// 实时显示
 229   3                              DA_CH2 = da_result; // 信号发生器
 230   3                      };break;
 231   2                      case 2:{         // 模式2 CH1实时显示 CH2回放显示
 232   3                              DA_CH1 = ad_result;// 实时显示
 233   3                              DA_CH2 = ad_memo[review_p++]; // 回放显示
 234   3                              if (review_p >= MEMO_LEN){ // 若显示指针到达存储区末尾，从头开始显示
 235   4                              review_p = 0;
 236   4                              }
 237   3                      };break;
 238   2                      case 3:{        // 模式3 测量模式
 239   3                              DA_CH1 = ad_result;// 实时测量 
 240   3                              DA_CH2 = 128; 
 241   3                      };break;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 5   

 242   2                      case 4:{        // 模式4 信号发生器调频、调幅
 243   3                              DA_CH1 = ad_result; // 实时显示
 244   3                              DA_CH2 = da_result; // 信号发生器       
 245   3                      };break;
 246   2                      default: ;break;
 247   2              }
 248   1      }
 249          void da_generator()
 250          {
 251   1              switch(wave_sel){ // 根据wave_sel的选择产生相应波形
 252   2                      case SIN:{      // 正弦波
 253   3                              angle++;
 254   3                              if(angle > 360){
 255   4                                      angle = 0;
 256   4                              }
 257   3                              sinAngle =      sin(((float)angle * PI / 180.0f));// 求角度对应的弧度值[-1,1]
 258   3                              da_result = (int)(((sinAngle + 1.0f) / 2.0f) * 255.0f); // 将[-1,1]内的sin值映射到[0,255]
 259   3                      };break;
 260   2                      case TRI:{      // 三角波
 261   3                              if(tri_flag){//递增
 262   4                                      tri_value++;
 263   4                                      if(tri_value == 255){
 264   5                                              tri_flag = 0;
 265   5                                      }       
 266   4                              }
 267   3                              else{//递减
 268   4                                      tri_value--;
 269   4                                      if(tri_value == 0){
 270   5                                              tri_flag = 1;
 271   5                                      }
 272   4                              }        
 273   3                              da_result = tri_value;  
 274   3                      };break;        
 275   2                      case REC:{      // 方波
 276   3                              rec_count++;
 277   3                              if(rec_count == 200){
 278   4                                      rec_count = 0;                  
 279   4                              }
 280   3                              if(rec_count>100){
 281   4                                      da_result = 255;
 282   4                              }else{
 283   4                                      da_result = 0;
 284   4                              }               
 285   3                      };break;
 286   2                      case SAW:{      // 锯齿波
 287   3                              saw_value++;
 288   3                              if(saw_value > 255){
 289   4                                      saw_value = 0;
 290   4                              }       
 291   3                              da_result = saw_value;
 292   3                      };break;
 293   2                      default:da_result = 128;break;  
 294   2              }
 295   1      }
 296          
 297          void dspbuf_measure()   // 将采样得到的频率和幅值显示到数码管上
 298          {
 299   1              // 频率值转换为数码管显示
 300   1              if(flag_fre){
 301   2                      unsigned int integer_fre = 0;
 302   2                      unsigned int fraction_fre = 0;
 303   2                      integer_fre = (int)fre_es;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 6   

 304   2                      dspbuf[3] = dspchar[integer_fre % 10];
 305   2                      dspbuf[2] = dspchar[integer_fre / 10 % 10];
 306   2                      dspbuf[1] = dspchar[integer_fre / 100 % 10];
 307   2                      dspbuf[0] = dspchar[integer_fre / 1000 % 10];
 308   2                      /*
 309   2                      if(fre_es >= 100 && fre_es <1000){ // 频率最大为三位数
 310   2                              integer_fre = (int)fre_es;
 311   2                              fraction_fre = (int)(10*(fre_es-integer_fre));  // 显示1位小数
 312   2                              dspbuf[3] = dspchar[fraction_fre];
 313   2                              dspbuf[2] = dspchar[integer_fre % 10] & 0xfe;// 加小数点
 314   2                              dspbuf[1] = dspchar[integer_fre / 10 % 10] ; 
 315   2                              dspbuf[0] = dspchar[integer_fre / 100 % 10];    
 316   2                      }
 317   2                      else if(fre_es >= 1000 && fre_es <10000) //频率为四位数
 318   2                      {
 319   2                              integer_fre = (int)fre_es; 
 320   2                              dspbuf[3] = dspchar[integer_fre % 10];
 321   2                              dspbuf[2] = dspchar[integer_fre / 10 % 10];
 322   2                              dspbuf[1] = dspchar[integer_fre / 100 % 10];    
 323   2                              dspbuf[0] = dspchar[integer_fre / 1000 % 10];
 324   2                      }
 325   2                      else if(fre_es > 0 && fre_es <10){//频率为一位数
 326   2                              integer_fre = (int)fre_es;
 327   2                              fraction_fre = (int)(1000*(fre_es - integer_fre));
 328   2                              dspbuf[0] = dspchar[integer_fre] & 0xfe;//加小数点
 329   2                              dspbuf[3] = dspchar[fraction_fre % 10];
 330   2                              dspbuf[2] = dspchar[fraction_fre / 10 % 10] ; 
 331   2                              dspbuf[1] = dspchar[fraction_fre / 100 % 10];           
 332   2                      }
 333   2                      */
 334   2              }
 335   1              // 幅值转换为数码管显示
 336   1              else if(flag_amp){
 337   2                      if(amp_es >= 0.0f && amp_es <10.0f){
 338   3                              unsigned int integer_amp = 0;
 339   3                              unsigned int fraction_amp = 0;
 340   3                              integer_amp = (int) amp_es;
 341   3                              fraction_amp = (int) ((amp_es-integer_amp)*1000);
 342   3                              dspbuf[0] = dspchar[integer_amp] & 0xfe;// 加小数点
 343   3                              dspbuf[1] = dspchar[fraction_amp / 100 % 10];
 344   3                              dspbuf[2] = dspchar[fraction_amp / 10 % 10];
 345   3                              dspbuf[3] = dspchar[fraction_amp % 10];
 346   3                      }
 347   2              } 
 348   1      }
 349          void ad_measure()       // 频率幅值单次检测
 350          {
 351   1              /*
 352   1              if(ad_result > ad_max + WIN_SIZE / 2){// 测量值超过最大值窗口上界
 353   1                      ad_max = ad_result; // 更新测量最大值
 354   1                      time_count = 1;         // 测量时间计数重新计数
 355   1                      fre_count = 1;          // 最大值采样次数重新计数为1，即当前值
 356   1              }
 357   1              else if(ad_result >= ad_max - WIN_SIZE / 2){// 测量值在窗口内
 358   1                      fre_count++;    // 最大值采样技术加1
 359   1              }
 360   1              if(ad_result < ad_min - WIN_SIZE / 2){// 测量值超过最小值窗口下界
 361   1                      ad_min = ad_result; //  更新测量最小值
 362   1              }
 363   1              */
 364   1              // 频率测量
 365   1              amp_p2 = ad_result;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 7   

 366   1              time_count++;
 367   1              if(amp_p2 > 128 && amp_p1 <= 128){
 368   2                      fre_p2 = time_count; 
 369   2                      if(fre_p1 != 0){
 370   3                              fre_sum = fre_sum + fabs(fre_p2 - fre_p1);
 371   3                              fre_count++;
 372   3                      }
 373   2                      fre_p1 = fre_p2;        
 374   2              }
 375   1              amp_p1 = amp_p2;
 376   1      
 377   1              // 幅值测量
 378   1              if(ad_result > ad_max){
 379   2                      ad_max = ad_result;
 380   2              }       
 381   1              if(ad_result < ad_min){
 382   2                      ad_min = ad_result;
 383   2              }
 384   1              if(time_count >= AD_LEN){
 385   2                      fre_es = 1500.0f / (fre_sum * 1.0f / fre_count);
 386   2                      amp_es = 5.0f * ((ad_max-ad_min)/256.0f);
 387   2                      fre_sum = 0;fre_count = 0;
 388   2                      time_count = 0;
 389   2                      fre_p1 = fre_p2 = 0;
 390   2                      amp_p1 = amp_p2 = 129;
 391   2                      ad_max = ad_min = 128;
 392   2              }
 393   1              /*
 394   1                      if(time_count >= 250){// 0.25ms*400=0.1s更新一次测量值
 395   1                              time_count = 0;
 396   1                              //fre_es = fre_count / 0.15f;  // 输出测量频率
 397   1                              fre_es = 500.0f / (fre_sum * 1.0f / fre_count);
 398   1                              amp_es = 5.0f*((ad_max - ad_min) / 256.0f); // 输出测量幅值
 399   1                              fre_sum = 0; fre_count = 0;
 400   1                              fre_p1 = fre_p2 = 1;
 401   1                              amp_p1 = amp_p2 = 129;
 402   1                              ad_max = ad_min = 128;
 403   1                      }
 404   1                 */   
 405   1      
 406   1      }
 407          
 408          void mode_select()      // 模式选择
 409          {
 410   1              switch(key_num){
 411   2                      case 1:{                // 模式1：实时采样+存储，信号发生器
 412   3                              mode = 1;
 413   3                              fdisp(1,0); // 数码管最左端显示模式1
 414   3                              fdisp(0,1);
 415   3                              fdisp(0,2);
 416   3                              fdisp(wave_sel,3);
 417   3                      };break;
 418   2                      case 2:{                // 模式2：实时采样，波形回放
 419   3                              mode = 2;
 420   3                              fdisp(2,0);     // 数码管最左端显示模式2
 421   3                              fdisp(0,1);
 422   3                              fdisp(0,2);
 423   3                              fdisp(0,3);     // 数码管最右端波形显示清零     
 424   3                      };break;
 425   2                      case 3:{                // 模式3：测量实时采样的幅值和频率（或周期）
 426   3                              mode = 3;
 427   3                              fdisp(3,0);
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 8   

 428   3                              fdisp(0,1);
 429   3                              fdisp(0,2);
 430   3                              fdisp(0,3);
 431   3                      };break;
 432   2                      case 4:{                // 信号发生器调频调幅
 433   3                              mode = 4;                       
 434   3                              fdisp(4,0);               // 数码管最左端显示模式4
 435   3                              fdisp(0,1);
 436   3                              fdisp(0,2);
 437   3                              fdisp(wave_sel,3);// 数码管最右端显示波形       
 438   3                      };break;
 439   2                      case 5:{
 440   3                              if(mode == 1){                  // 模式1下，按键5表示选择正弦波
 441   4                                      wave_sel = SIN;
 442   4                                      fdisp(wave_sel,3);      // 在数码管最右端显示波形选择
 443   4                              }
 444   3                              else if(mode == 2){;}
 445   3                              else if(mode == 3){             // 模式3下，按键5显示测量频率
 446   4                                      flag_amp = 0;                                                                                                                            
 447   4                                      flag_fre = 1;
 448   4                              }
 449   3                              else if(mode == 4){             // 模式4下，按键5表示频率1
 450   4                                      /*if(gen_count >= 50000){
 451   4                                              gen_count = 50000;
 452   4                                      }
 453   4                                      else{
 454   4                                              gen_count++;
 455   4                                      }
 456   4                                      */
 457   4                                      if(fre_modi){
 458   5                                              gen_count = 4;
 459   5                                      }
 460   4                                      if(amp_modi){
 461   5                                              da_index = 2;
 462   5                                      }
 463   4                                      //gen_count = 4;
 464   4                                      //da_index = 2;
 465   4                              }
 466   3                      };break;
 467   2                      case 6:{
 468   3                              if(mode == 1){                  // 模式1下，按键5表示选择三角波
 469   4                                      wave_sel = TRI;
 470   4                                      fdisp(wave_sel,3);
 471   4                              }
 472   3                              else if(mode == 3){             // 模式3下，按键6表示测量幅值
 473   4                                      flag_fre = 0;
 474   4                                      flag_amp = 1;           
 475   4                              } 
 476   3                              else if(mode == 4){             // 模式4下，按键6表示频率2
 477   4                                      /*
 478   4                                      if(gen_count <= 4){
 479   4                                              gen_count = 4;
 480   4                                      }else{
 481   4                                              gen_count--;
 482   4                                      }
 483   4                                      */
 484   4                                      if(fre_modi){
 485   5                                              gen_count = 3;
 486   5                                      }
 487   4                                      if(amp_modi){
 488   5                                              da_index = 3;
 489   5                                      }
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 9   

 490   4                              }       
 491   3                      };break;
 492   2                      case 7:{
 493   3                              if(mode == 1){                  // 模式1下，按键7表示选择方波
 494   4                                      wave_sel = REC;         
 495   4                                      fdisp(wave_sel,3);      
 496   4                              }
 497   3                              else if(mode == 3){
 498   4                                      fre_modi = 1;
 499   4                                      amp_modi = 0;
 500   4                              }
 501   3                              else if(mode == 4){             // 模式4下，按键7表示幅度减小,频率3
 502   4                                      /*
 503   4                                      if(da_index <= 1000){
 504   4                                              da_index = 1000;
 505   4                                      }
 506   4                                      else{
 507   4                                              da_index--;
 508   4                                      }
 509   4                                      */
 510   4                                      if(fre_modi){
 511   5                                              gen_count = 2;
 512   5                                      }
 513   4                                      if(amp_modi){
 514   5                                              da_index = 4;
 515   5                                      }
 516   4                              }
 517   3                      };break;
 518   2                      case 8:{                                        
 519   3                              if(mode == 1){                  // 模式1下，按键8表示选择锯齿波
 520   4                                      wave_sel = SAW;
 521   4                                      fdisp(wave_sel,3);
 522   4                              }
 523   3                              else if(mode == 3){
 524   4                                      fre_modi = 0;
 525   4                                      amp_modi = 1;
 526   4                              }
 527   3                              else if(mode == 4){             // 模式4下，按键8表示幅度增大,频率4
 528   4                                      /*
 529   4                                      if(da_index >= 5000){
 530   4                                              da_index = 5000;
 531   4                                      }
 532   4                                      else{
 533   4                                              da_index++;
 534   4                                      }
 535   4                                      */
 536   4                                      if(fre_modi){
 537   5                                              gen_count = 1;
 538   5                                      }
 539   4                                      if(amp_modi){
 540   5                                              da_index = 5;
 541   5                                      }
 542   4                              }
 543   3                      }; break;
 544   2                      default:break;
 545   2              }
 546   1              
 547   1      }
 548          /*
 549          unsigned char amp = 128;
 550          unsigned char amp_up = 128, amp_low =128;
 551          float adamp = 0.0f;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 10  

 552          unsigned int num = 0;
 553          void amp_measure() // 幅值测量
 554          {
 555              //int i = 0;
 556              amp = ad_result;
 557              memo_p++;
 558              if (amp > amp_up)
 559              {
 560                  amp_up = amp;
 561              }
 562              if (amp < amp_low)
 563              {
 564                  amp_low = amp;
 565              }
 566              if (memo_p >= MEMO_LEN)
 567              {
 568                  adamp = (amp_up * 5.0 - amp_low * 5.0) / 256;
 569                  memo_p = 0;
 570                  amp_up = amp_low = 128;
 571              }
 572          
 573              num =(int)adamp*1000;
 574                  fdisp(num%10,0);
 575                  fdisp(num/10%10,1);
 576                  fdisp(num/100%10,2);
 577                  fdisp(num/1000%10,3);
 578          }
 579          */
 580          
 581          void key_service()
 582          {
 583   1              if(key_sta & 0x01) return;//key_sta.0 = 1，按键为按下状态
 584   1              // key_sta.0 = 0，按键为弹起状态，检测到KEY1/KEY2行有按键被按下
 585   1              if(KEY1){
 586   2                      key_num = key_col + 1; 
 587   2                      key_sta = key_sta | 0x01;//key_sta.0 = 1
 588   2              }       
 589   1              else if(KEY2){
 590   2                      key_num = key_col + 5;
 591   2                      key_sta = key_sta | 0x01;//key_sta.0 = 1        
 592   2              }
 593   1              
 594   1      }
 595          /*
 596          void ad_delay()
 597          {
 598              _nop_();
 599              _nop_();
 600              _nop_();
 601              _nop_();
 602          }
 603          */
 604          /*
 605          void ad_get()
 606          {
 607              ADC_RES = 0;       // ADC存储缓存清零
 608              ADC_CONTR |= 0x08; // ADCSTART = 1
 609              ad_delay();        // 必要的4个nop
 610              while (ADC_CONTR & 0x10 == 0)
 611                  ;                // ADC_FLAG = 0,等待ADC_FLAG = 1
 612              ADC_CONTR &= 0xE7;   // 上述两位清零等待下次采样
 613              ad_result = ADC_RES; // 保存采样值
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 11  

 614          }
 615          */
 616          
 617          void ad_save() // A/D采样值存储
 618          {
 619   1          ad_memo[memo_p++] = ad_result;
 620   1          if (memo_p >= MEMO_LEN)
 621   1          {
 622   2              memo_p = 0;
 623   2          }
 624   1      }
 625          
 626          void dsptask()
 627          {
 628   1          unsigned char i;    // for loop 临时变量
 629   1          unsigned char a, b; // a:数码管位选，b:掩码
 630   1      
 631   1          // 数码管位选
 632   1          switch (sel)
 633   1          {
 634   2          case 0:        // L1-T204
 635   2              a = 0x01;
 636   2              break; 
 637   2          case 1:        // L2-T203
 638   2              a = 0x02;  
 639   2              break; 
 640   2          case 2:        // L3-T202
 641   2              a = 0x04;
 642   2              break;          
 643   2          default:   // L4-T201
 644   2              a = 0x08; 
 645   2          }
 646   1              // 将表示数码管位选的信息输入到74HC565的高位8bit 
 647   1              // 对应数码管的COM1为高电平（共阳极数码管）
 648   1          for (b = 0x80, i = 0; i < 8; i++)
 649   1          {
 650   2              if (a & b)
 651   2                  D_SER = 1;
 652   2              else
 653   2                  D_SER = 0;
 654   2              D_SRCLK = 0;
 655   2              D_SRCLK = 1;
 656   2              D_SRCLK = 0;
 657   2              b = b >> 1;
 658   2              // b=b&0x7f;
 659   2          }
 660   1          // 载入位选数码管对应的显示内容
 661   1          a = dspbuf[sel];
 662   1              // 按键列选择
 663   1              key_col = sel;
 664   1              // 索引改变，选择下一个数码管
 665   1          sel++;
 666   1          if (sel >= 4)
 667   1              sel = 0; 
 668   1              // 将数码管对应显示内容输入到级联74HC565的低8bit
 669   1          for (b = 0x80, i = 0; i < 8; i++)
 670   1          {
 671   2              if (a & b)
 672   2                  D_SER = 1;
 673   2              else
 674   2                  D_SER = 0;
 675   2              D_SRCLK = 0;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 12  

 676   2              D_SRCLK = 1;
 677   2              D_SRCLK = 0;
 678   2              b = b >> 1;
 679   2              // b=b&0x7fff;
 680   2          }
 681   1          D_RCLK = 0;
 682   1          D_RCLK = 1;
 683   1          D_RCLK = 0;
 684   1      }
 685          void fdisp(unsigned char n,unsigned char m)
 686          {
 687   1              char c;
 688   1              switch(n){
 689   2                      case 0: c = 0x11; break;
 690   2                      case 1: c = 0x7d; break;
 691   2                      case 2: c = 0x23; break;
 692   2                      case 3: c = 0x29; break;
 693   2                      case 4: c = 0x4d; break;
 694   2                      case 5: c = 0x89; break;
 695   2                      case 6: c = 0x81; break;
 696   2                      case 7: c = 0x3d; break;
 697   2                      case 8: c = 0x01; break;
 698   2                      case 9: c = 0x09; break;
 699   2                      default:c = 0xff; break;
 700   2              }
 701   1              dspbuf[m] = c;
 702   1      }
 703          unsigned char ad_get()
 704          {
 705   1          ADC_CONTR = ADC_CONTR | ADC_POWER | 3 | ADC_START;
 706   1          _nop_(); // wait
 707   1          _nop_();
 708   1          _nop_();
 709   1          _nop_();
 710   1          while (!(ADC_CONTR & ADC_FLAG))
 711   1              ;                   // 等待A/D标志位变1，ADC_FLAG
 712   1          ADC_CONTR &= ~ADC_FLAG; // 标志位清零
 713   1          return ADC_RES;
 714   1      }
 715          
 716          
 717          void init_ad() // ad寄存器初始化
 718          {
 719   1          P1ASF = 0x08;     // P1.3作为ad输入
 720   1          ADC_CONTR = 0xE3; // ADC控制寄存器         Bit7    Bit6    Bit5    Bit4    Bit3    Bit2    Bit1    Bit
             -0
 721   1                            // 位描述            ADC_POWER  SPEED1 SPEED0 ADC_FLAG ADC_START CHS2    CHS1    CHS
             -0
 722   1                            // 初始值=0000,0000      0       0       0       0       0       0       0       0
 723   1                            // 设置值=0000,0000      1       1       1       0       0       0       1       1
 724   1          AUXR1 &= 0xfb;    // 高8位存储在在ADC_RES
 725   1          CLK_DIV = 0x01;   // 系统时钟/2
 726   1      }
 727          void init_special_interrupts() // 中断初始化
 728          {
 729   1          EX0 = 0;
 730   1          ET0 = 1; // 定时器0中断
 731   1          EX1 = 0;
 732   1          ET1 = 1; // 定时器1中断
 733   1          ES = 1;
 734   1          EA = 1; // 总中断
 735   1          PT0 = 0;
C51 COMPILER V9.01   TEST1                                                                 05/11/2023 14:30:18 PAGE 13  

 736   1          PX1 = 1;
 737   1          PS = 0;
 738   1      }
 739          void init_timer0() // 定时器0初始化
 740          {                  // 1/4ms
 741   1          TMOD &= 0XF0;  // Timer0设置清除
 742   1          TMOD |= 0X02;  // 8位自动重载
 743   1          TL0 = 0X06;
 744   1          TH0 = 0X06;
 745   1          TR0 = 1;
 746   1          ET0 = 1;
 747   1      }
 748          
 749          
 750          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1894    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   8000    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     71       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
